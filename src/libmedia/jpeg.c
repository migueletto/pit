#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <setjmp.h>

#include <jpeglib.h>

#include "jpeg.h"
#include "debug.h"
#include "xalloc.h"

struct my_error_mgr {
  struct jpeg_error_mgr pub;
  jmp_buf setjmp_buffer;
};

static unsigned char huffman_table[] = {
  0xFF,0xC4,0x01,0xA2,0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,
  0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
  0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x01,0x00,0x03,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
  0x0A,0x0B,0x10,0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,
  0x05,0x04,0x04,0x00,0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,
  0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,
  0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,
  0x52,0xD1,0xF0,0x24,0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,
  0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,0x35,0x36,
  0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,
  0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,
  0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,
  0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,
  0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,
  0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,
  0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,
  0xD6,0xD7,0xD8,0xD9,0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
  0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,
  0xFA,0x11,0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,
  0x04,0x04,0x00,0x01,0x02,0x77,0x00,0x01,0x02,0x03,0x11,0x04,
  0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,
  0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,
  0x52,0xF0,0x15,0x62,0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,
  0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,0x29,0x2A,0x35,0x36,
  0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,
  0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,
  0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,
  0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,
  0x95,0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,
  0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,
  0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,
  0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
  0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA
};

static void my_error_exit(j_common_ptr cinfo) {
  struct my_error_mgr *myerr = (struct my_error_mgr *)cinfo->err;
  (*cinfo->err->output_message)(cinfo);
  longjmp(myerr->setjmp_buffer, 1);
}

static void my_output_message(j_common_ptr cinfo) {
  char buf[JMSG_LENGTH_MAX];
  (*cinfo->err->format_message)(cinfo, buf);
  debug(DEBUG_INFO, "JPEG", "jpeglib error %s", buf);
}

static void jpeg_compress(struct jpeg_compress_struct *cinfo, unsigned char *buf, int width, int height, int fwidth, int fheight, int quality) {
  JSAMPROW rowPointer[1];

  cinfo->image_width = width;
  cinfo->image_height = height;
  cinfo->input_components = 3;
  cinfo->in_color_space = JCS_RGB;

  jpeg_set_defaults(cinfo);
  jpeg_set_quality(cinfo, quality, TRUE);

  jpeg_start_compress(cinfo, TRUE);
  while (cinfo->next_scanline < cinfo->image_height) {
    rowPointer[0] = (unsigned char *)&buf[cinfo->next_scanline * fwidth * 3];
    jpeg_write_scanlines(cinfo, rowPointer, 1);
  }
  jpeg_finish_compress(cinfo);
}

unsigned char *encode_jpeg(unsigned char *buf, int width, int height, int fwidth, int fheight, int quality, int *encoded_len) {
  struct jpeg_compress_struct cinfo;
  struct my_error_mgr jerr;
  unsigned char *outbuf;
  unsigned long outlen;

  memset(&cinfo, 0, sizeof(cinfo));
  cinfo.err = jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  jerr.pub.output_message = my_output_message;

  jpeg_create_compress(&cinfo);
  outbuf = NULL;
  outlen = 0;
  jpeg_mem_dest(&cinfo, &outbuf, &outlen);

  if (setjmp(jerr.setjmp_buffer)) {
    debug(DEBUG_ERROR, "JPEG", "jpeg encode error");
    jpeg_destroy_compress(&cinfo);
    *encoded_len = 0;
    return NULL;
  }

  jpeg_compress(&cinfo, buf, width, height, fwidth, fheight, quality);
  jpeg_destroy_compress(&cinfo);

  *encoded_len = outlen;
  return outbuf;
}

unsigned char *check_huffman_table(unsigned char *buf, int len, int *outlen) {
  unsigned char *outbuf;
  unsigned int size;
  int i, found;

  *outlen = len;

  if (len < 2 || buf[0] != 0xff || buf[1] != 0xd8) {
    return buf;
  }

  found = 0;

  for (i = 2; i < len-3;) {
    if (buf[i] != 0xff) {
      return buf;
    }

    if (buf[i+1] == 0xc4) {
      // huffman table already defined
      return buf;

    } else if (buf[i+1] == 0xda) {
      // found start of scan, no previous huffman table
      found = 1;
      break;

    } else {
      size = (((unsigned int)buf[i+2]) << 8) | buf[i+3];
      i += size + 2;
    }
  }

  if (!found) {
    debug(DEBUG_ERROR, "JPEG", "start of scan not found");
    return buf;
  }

  // insert huffman table

  *outlen = len + sizeof(huffman_table);
  outbuf = xmalloc(*outlen);

  memcpy(outbuf, buf, i);
  memcpy(outbuf + i, huffman_table, sizeof(huffman_table));
  memcpy(outbuf + i + sizeof(huffman_table), buf+i, len - i);

  return outbuf;
}

unsigned char *decode_jpeg(unsigned char *buf, int len, int *decoded_len, int *width, int *height) {
  struct jpeg_decompress_struct cinfo;
  struct my_error_mgr jerr;
  unsigned long bmp_size;
  unsigned char *bmp_buffer;
  int row_stride, w, h, pixel_size;

  bmp_size = 0;
  bmp_buffer = NULL;

  memset(&cinfo, 0, sizeof(cinfo));
  cinfo.err = jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  jerr.pub.output_message = my_output_message;

  if (setjmp(jerr.setjmp_buffer)) {
    jpeg_destroy_decompress(&cinfo);
    debug(DEBUG_ERROR, "JPEG", "jpeg decode error");
    *decoded_len = 0;
    return NULL;
  }

  jpeg_create_decompress(&cinfo);
  jpeg_mem_src(&cinfo, buf, len);

  if (jpeg_read_header(&cinfo, TRUE) == 1) {
    jpeg_start_decompress(&cinfo);

    w = cinfo.output_width;
    h = cinfo.output_height;
    pixel_size = cinfo.output_components;

    bmp_size = w * h * pixel_size;
    bmp_buffer = xmalloc(bmp_size);
    row_stride = w * pixel_size;

    while (cinfo.output_scanline < cinfo.output_height) {
      unsigned char *buffer_array[1];
      buffer_array[0] = bmp_buffer + (cinfo.output_scanline) * row_stride;
      jpeg_read_scanlines(&cinfo, (unsigned char **)buffer_array, 1);
    }

    jpeg_finish_decompress(&cinfo);

    if (width) *width = w;
    if (height) *height = h;
  }
  jpeg_destroy_decompress(&cinfo);

  *decoded_len = bmp_size;

  return bmp_buffer;
}
